#include <iostream>
#include <vector>
#include <string>

using namespace std;

/*
문제 풀이 아이디어

처음에는 수학적인 규칙성이 있을거 같았는데
30번째까지 써보니 코드 구현이 더 복잡할거 같았다.
시간 복잡도를 생각하니 1씩 증가시키면서 while loop으로 하나씩 666이 포함된 수인지 검사하는 방식을 사용했다.
처음 숫자 666으로 시작하여 loop를 돌려 처음 숫자를 계속 1씩 더하며 숫자를 문자열로 변환 후 문자열 "666" 문자열이 포함되어 있으면
count 횟수를 세어 n과 일치하면 loop 탈출 후
1씩 증가시킨 숫자를 출력한다.

시간복잡도
n의 최대값 10000번째 영화 제목은 2666799이다. 최대로 나올 수 있는 경우를 생각해보면 666에서 1666까지 1씩 증가하며 loop를 돌리면
1000번이 걸리는데 n의 최대와 곱하면 10^7이다. find 함수의 시간복잡도는 O(N)이지만 문자열의 길이가 최대 7개라서
최악의 케이스는 7*10^7 < 10^8 이므로 문제의 시간 제한 2초보다 적게 걸릴 것이다.
*/

int n; // n번째 영화 제목

int main()
{
	cin >> n;

	int count = 0; // loop에서 "666"이 들어가면 횟수를 세는 변수
	int result = 666; // 결과 변수 666부터 시작하면 더 빠르게 검사할 수 있음
	while (true)
	{
		if (count == n) break; // "666"이 들어가면 횟수를 세어 n이 되면 loop 종료
		string str = to_string(result); // 숫자를 문자열로 변환
		if (str.find("666") != string::npos) { // 변환한 문자열에 "666"이 있는지 검사
			count++; // true -> count를 1증가시켜 "666"이 들어간 숫자를 셈
		}
		result++; // loop를 돌때마다 1씩 증가
	}

	cout << result - 1 << endl; // 출력 loop마지막에 1씩 증가하고 종료되기 때문에 1을 빼줌
}
