#include <iostream>
#include <algorithm>

using namespace std;

/*
문제 풀이 아이디어
처음에는 브루트포스 느낌으로
한번 움직일 수 있을때를 체크하고
마지막 배열의 최댓값을 구하려고 했는데
반복문으로 풀었는데 2차원벡터에 안에 pair까지 사용해서
메모리 초과가 났다.

계단마다 점수의 최댓값을 구해 dp 배열에 저장하고
첫번째 계단은 arr[1] 이고,
두번째 계단은 arr[1] + arr[2] 이 최대고
세번째 계단은 arr[1] + arr[3] or arr[2] + arr[3] 이 최대가 된다.
네번째 계단과 다섯번째 계단부터 계산을 해보니 규칙성이 발견되어서
점화식처럼 써졌다.

계산은 마지막 계단은 무조건 밟아야 되므로 arr[n]을 더해줘야하고
arr[n-1] 또는 arr[n-2] 기준으로 계산을 이어했다.
이전 계단과 붙어 있으면 그전 최댓값 dp[n-3]가 더해지고
안붙어 있으면 전전 계단의 최댓값 dp[n-2]가 더해진다.

4번째 계단 10 + 20 + 25 또는 10 + 15 + 25
5번째 계단은 10 + 20 + 25 + 10 또는 20 + 15 + 25 + 10 
점화식으로 써보면
dp[n] = arr[n] + arr[n-1] + dp[n-3] 또는
dp[n] = arr[n] + dp[n-2] 가된다.

둘중 최댓값을 구해서 dp[n]에 저장하여 갱신하면
마지막에 최댓값이 나온다.

시간 복잡도
O(N)
*/

int n;
int arr[301]; // 계단 점수
int dp[301]; // 계단 점수 합의 최댓값

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> arr[i];
	}

	dp[1] = arr[1];
	dp[2] = arr[1] + arr[2];
	dp[3] = max(arr[1] + arr[3], arr[2] + arr[3]);

	for (int i = 4; i <= n; i++) {
		dp[i] = max(arr[i] + dp[i - 2], arr[i] + arr[i - 1] + dp[i - 3]);
	}
	
	cout << dp[n] << '\n';
}
